<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!doctype html>
</head>

    <head>
        <style>
            .axis text {
                font: 10px sans-serif;
            }
            .axis .title {
                font-weight: bold;
                text-anchor: middle;
            }
            .axis path,
            .axis line {
                fill: none;
                stroke: #000;
                shape-rendering: crispEdges;
            }
            .x.axis path {
                fill: none;
                stroke: #000;
                shape-rendering: crispEdges;

            }
            .viewport {
                stroke: grey;
                fill: none;
                fill-opacity: 0.3;
            }
            .viewport .extent {
                fill: green;
            }
            .nav{
                fill: darkgray;
                stroke: black;
            }
            .well {
                padding-top: 0px;
                padding-bottom: 0px;
            }
        </style>
<body>

<div style="max-width: 600px; max-height: 400px; padding: 3px">

    <div class="well">
    </div>

    <div id="viewDiv"></div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
<script src="jschart.js"></script>
<script>
    'use strict';


    // define time scale
    let timeScale = d3.scale.linear()
        .domain([300, 1700])
        .range([300, 1700])
        .clamp(true);

    // define value scale
    let valueScale = d3.scale.linear()
        .domain([0, 1])
        .range([30, 95]);

    // generate initial data
    let normal = d3.random.normal(1000, 150);
    let currMs = new Date().getTime();
    let data = d3.range(300).map(function(d, i, arr) {
        let value = valueScale(Math.random()); // random data
        let interval = Math.round(timeScale(normal()));
        currMs += interval;
        let time = new Date(currMs);
        let obj = { interval: interval, value: value, time: time, ts: currMs };
        return obj;
    });
    d3.csv("pivo_500ms_packet_drops.csv", function(error, data) {
        let chart = datarealTimeChart()
            .border(true)
            .yTitle("data")
            .xTitle("time")
            .width(400)
            .height(200)
            .barWidth(1)
            .initialData([]);

        // invoke the chart
        let chartDiv = d3.select("#viewDiv").append("div")
            .attr("id", "chartDiv")
            .call(chart);


        // drive data into the chart roughly every second
        // in a normal use case, real time data would arrive through the network or some other mechanism
        let d = 0;
        function dataGenerator() {
            let timeout = 20;

            setTimeout(function () {

                // create new data item
                let now = new Date();
                let obj = {
                    value: data[d].value, // random data
                    time: now,
                    color: "red",
                    ts: now.getTime(),
                    interval: timeout
                };

                d++;

                // send the datum to the chart
                chart.datum(obj);

                // do forever
                dataGenerator();

            }, timeout);
        }


        // start the data generator
        dataGenerator();
    });
    d3.csv("sin.csv", function(error, data) {
        let chart = datarealTimeChart()
            .border(true)
            .yTitle("data")
            .xTitle("time")
            .width(400)
            .height(200)
            .barWidth(1)
            .initialData([]);

        // invoke the chart
        let chartDiv = d3.select("#viewDiv").append("div")
            .attr("id", "chartDiv")
            .call(chart);


        // drive data into the chart roughly every second
        // in a normal use case, real time data would arrive through the network or some other mechanism
        let d = 0;
        function dataGenerator() {
            let timeout = 20;

            setTimeout(function () {

                // create new data item
                let now = new Date();
                let obj = {
                    value: data[d].value, // random data
                    time: now,
                    color: "red",
                    ts: now.getTime(),
                    interval: timeout
                };

                d++;

                // send the datum to the chart
                chart.datum(obj);

                // do forever
                dataGenerator();

            }, timeout);
        }


        // start the data generator
        dataGenerator();
    });
    d3.csv("pivo_500ms_simulation_speed_test.csv", function(error, data) {
        let chart = datarealTimeChart()
            .border(true)
            .yTitle("data")
            .xTitle("time")
            .width(400)
            .height(200)
            .barWidth(1)
            .initialData([]);

        // invoke the chart
        let chartDiv = d3.select("#viewDiv").append("div")
            .attr("id", "chartDiv")
            .call(chart);


        // drive data into the chart roughly every second
        // in a normal use case, real time data would arrive through the network or some other mechanism
        let d = 0;
        function dataGenerator() {
            let timeout = 20;

            setTimeout(function () {

                // create new data item
                let now = new Date();
                let obj = {
                    value: data[d].value, // random data
                    time: now,
                    color: "red",
                    ts: now.getTime(),
                    interval: timeout
                };

                d++;

                // send the datum to the chart
                chart.datum(obj);

                // do forever
                dataGenerator();

            }, timeout);
        }


        // start the data generator
        dataGenerator();
    });

</script>

</body>
</html>
